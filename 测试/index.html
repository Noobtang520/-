<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>祝宝宝生日快乐！！！ </title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui-overlay {
            position: absolute; top: 30px; left: 30px; color: white;
            pointer-events: none; z-index: 10;
        }
        .status-badge {
            background: rgba(255, 120, 0, 0.1); padding: 12px 24px;
            border-radius: 4px; backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 136, 0, 0.2); margin-bottom: 10px;
            display: inline-block; font-size: 11px; letter-spacing: 2px;
            text-transform: uppercase; color: #ffaa00;
        }
        #video-preview {
            position: absolute; bottom: 30px; right: 30px;
            width: 160px; height: 120px; border-radius: 4px;
            border: 1px solid rgba(255, 136, 0, 0.2); transform: scaleX(-1);
            opacity: 0.4;
        }
        .loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
            transition: opacity 1s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .core-loader {
            width: 60px; height: 60px; border: 1px solid #ff8800;
            border-top-color: transparent; border-radius: 50%;
            animation: spin 1.5s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Help prompt */
        #local-tip {
            position: fixed; bottom: 160px; right: 30px;
            color: #ffaa00; font-size: 10px; background: rgba(0,0,0,0.5);
            padding: 5px; border-radius: 3px; pointer-events: none;
        }
    </style>
</head>
<body>

<div id="loading" class="loading-screen">
    <div class="core-loader"></div>
    <p style="color: #ff8800; margin-top: 30px; font-size: 10px; letter-spacing: 5px;">星形引擎重建中</p>
</div>

<div id="ui-overlay">
    <div class="status-badge" id="gesture-status">系统待机</div><br>
    <div class="status-badge">交互深度: <span id="open-val">0%</span></div>
</div>


<video id="video-preview" autoplay playsinline></video>
<div id="canvas-container"></div>

<script>
    const CONFIG = {
        planetSurfaceCount: 10000,
        planetCoreCount: 22000, // 稍微降低数量提升性能
        photoCount: 9,
        ringCount: 15000,
        baseRadius: 4.8,
        ringRadius: 8.5,
        camDistance: 16,
        autoRotateSpeed: 0.0012,
        ringRotateSpeed: 0.0005,
        distFar: 0.12,
        distNear: 0.38,
        photoBaseSize: 2.0,
        floatIntensity: 0.4,
        photoDisplayThreshold: 0.3,
        pinchThreshold: 0.06
    };

    let scene, camera, renderer, planet, ring, pointsGroup;
    let handTracker, videoElement;
    let photoSprites = [];

    let openFactor = 0, targetOpenFactor = 0;
    let rotationVelocity = { x: 0, y: 0 };
    let isHandActive = false;
    let isPinching = false;
    let focusedPhotoIndex = -1;
    let currentNumber = 0;
    let originalData = {
        planet: null, ring: null, ringNoise: null,
        textPoints: {}, noiseOffsets: null
    };

    // ======================================================
    // === 图片加载逻辑 (修复版) ===
    // ======================================================
    async function generateSpaceImages() {
        const textureLoader = new THREE.TextureLoader();
        const textures = [];

        // 修改点 1: 路径修复。建议将图片放在项目下的 images 文件夹，使用相对路径
        // 注意：Windows 路径的 \ 要换成 /
        const myImages = [
            'images/Image_36870193656658.jpg',
            'images/Image_36871810682504.jpg',
            'images/Image_61024273388328.jpg',
            'images/mmexport1714910546871.jpg',
            'images/mmexport1714910574805.jpg',
            'images/mmexport1714972547026.jpg',
            'images/mmexport1715154032014.jpg',
            'images/mmexport1722327175971.jpg',
            'images/mmexport1732682447898.jpg',
        ];

        // 辅助函数：将加载转为 Promise
        const loadTexture = (url) => {
            return new Promise((resolve) => {
                textureLoader.load(
                    url,
                    (tex) => resolve(tex),
                    undefined,
                    () => {
                        console.warn("加载失败，创建占位图: " + url);
                        resolve(createPlaceholderTexture());
                    }
                );
            });
        };

        for (let url of myImages) {
            const tex = await loadTexture(url);
            textures.push(tex);
        }

        return textures;
    }

    function createPlaceholderTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = "#ff8800"; ctx.fillRect(0,0,512,512);
        ctx.strokeStyle = "white"; ctx.lineWidth = 20; ctx.strokeRect(40,40,432,432);
        ctx.fillStyle = "white"; ctx.font = "bold 40px Arial";
        ctx.textAlign = "center"; ctx.fillText("MISSING IMG", 256, 256);
        return new THREE.CanvasTexture(canvas);
    }
    // ======================================================

    function getTextPoints(text, fontSize = 180) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1024; canvas.height = 512;
        ctx.fillStyle = 'white';
        ctx.font = `900 ${fontSize}px "Microsoft YaHei", "SimHei", sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const points = [];
        const step = 2;
        for (let y = 0; y < canvas.height; y += step) {
            for (let x = 0; x < canvas.width; x += step) {
                if (imageData.data[(y * canvas.width + x) * 4 + 3] > 120) {
                    points.push({ x: (x - canvas.width / 2) * 0.015, y: -(y - canvas.height / 2) * 0.015 });
                }
            }
        }
        return points;
    }

    function createStellarTexture(isWhite = false) {
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
        grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
        grad.addColorStop(0.2, isWhite ? 'rgba(200, 230, 255, 0.8)' : 'rgba(255, 180, 50, 0.9)');
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, 128, 128);
        return new THREE.CanvasTexture(canvas);
    }

    async function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.camDistance;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        originalData.textPoints[1] = getTextPoints("祝", 260);
        originalData.textPoints[2] = getTextPoints("宝宝", 240);
        originalData.textPoints[3] = getTextPoints("生日快乐", 200);

        pointsGroup = new THREE.Group();
        scene.add(pointsGroup);

        const totalParticles = CONFIG.planetSurfaceCount + CONFIG.planetCoreCount;
        const pGeo = new THREE.BufferGeometry();
        const pPos = new Float32Array(totalParticles * 3);
        const pTarget = new Float32Array(totalParticles * 3);
        const pType = new Float32Array(totalParticles);
        const pNoise = new Float32Array(totalParticles * 3);

        for (let i = 0; i < totalParticles; i++) {
            const i3 = i * 3;
            pNoise[i3] = Math.random() * 2.0 + 0.5;
            pNoise[i3+1] = Math.random() * 2.0 + 0.5;
            pNoise[i3+2] = Math.random() * Math.PI * 2;

            if (i < CONFIG.planetSurfaceCount) {
                let phi = Math.acos(-1 + (2 * i) / CONFIG.planetSurfaceCount);
                let theta = Math.sqrt(CONFIG.planetSurfaceCount * Math.PI) * phi;
                let r = CONFIG.baseRadius + (Math.random() - 0.5) * 0.4;
                pType[i] = 0;
                const dir = new THREE.Vector3(Math.sin(phi)*Math.cos(theta), Math.sin(phi)*Math.sin(theta), Math.cos(phi)).normalize();
                pTarget[i3] = dir.x * 45; pTarget[i3+1] = dir.y * 45; pTarget[i3+2] = dir.z * 45;
                pPos[i3] = r * Math.sin(phi) * Math.cos(theta);
                pPos[i3+1] = r * Math.sin(phi) * Math.sin(theta);
                pPos[i3+2] = r * Math.cos(phi);
            } else {
                let theta = 2 * Math.PI * Math.random();
                let phi = Math.acos(2 * Math.random() - 1);
                let r = Math.pow(Math.random(), 0.7) * CONFIG.baseRadius;
                pType[i] = 1;
                pTarget[i3] = (Math.random() - 0.5) * 50; pTarget[i3+1] = (Math.random() - 0.5) * 50; pTarget[i3+2] = (Math.random() - 0.5) * 40;
                pPos[i3] = r * Math.sin(phi) * Math.cos(theta);
                pPos[i3+1] = r * Math.sin(phi) * Math.sin(theta);
                pPos[i3+2] = r * Math.cos(phi);
            }
        }

        originalData.planet = new Float32Array(pPos);
        originalData.noiseOffsets = pNoise;
        pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        pGeo.setAttribute('targetPos', new THREE.BufferAttribute(pTarget, 3));
        pGeo.setAttribute('type', new THREE.BufferAttribute(pType, 1));

        planet = new THREE.Points(pGeo, new THREE.PointsMaterial({
            color: 0xffaa00, size: 0.18, map: createStellarTexture(false),
            transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
        }));
        pointsGroup.add(planet);

        const photoTextures = await generateSpaceImages();
        photoTextures.forEach((tex, idx) => {
            const mat = new THREE.SpriteMaterial({
                map: tex,
                transparent: true,
                opacity: 0,
                depthTest: false // 确保在粒子系统上方清晰可见
            });
            const sprite = new THREE.Sprite(mat);
            const r = CONFIG.baseRadius + 2.0 + Math.random() * 4.0;
            const theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1);
            sprite.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
            sprite.userData = {
                originPos: sprite.position.clone(),
                targetPos: new THREE.Vector3((Math.random()-0.5)*35, (Math.random()-0.5)*35, (Math.random()-0.5)*15),
                floatSeed: Math.random() * 10,
                floatSpeed: Math.random() * 0.5 + 0.2
            };
            photoSprites.push(sprite);
            pointsGroup.add(sprite);
        });

        const rGeo = new THREE.BufferGeometry();
        const rPosArr = new Float32Array(CONFIG.ringCount * 3);
        const rNoiseArr = new Float32Array(CONFIG.ringCount);
        for (let i = 0; i < CONFIG.ringCount; i++) {
            const i3 = i * 3;
            const angle = Math.random() * Math.PI * 2, r = CONFIG.ringRadius + (Math.random() - 0.5) * 6.0;
            rPosArr[i3] = Math.cos(angle) * r; rPosArr[i3+1] = (Math.random() - 0.5) * 1.5; rPosArr[i3+2] = Math.sin(angle) * r;
            rNoiseArr[i] = Math.random() * Math.PI * 2;
        }
        originalData.ring = rPosArr;
        originalData.ringNoise = rNoiseArr;
        rGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(rPosArr), 3));
        ring = new THREE.Points(rGeo, new THREE.PointsMaterial({
            color: 0xffffff, size: 0.12, map: createStellarTexture(true),
            transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false
        }));
        ring.rotation.x = Math.PI * 0.15;
        pointsGroup.add(ring);

        setupHandTracking();
        animate();
        window.addEventListener('resize', onWindowResize);
    }

    function setupHandTracking() {
        videoElement = document.getElementById('video-preview');
        handTracker = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
        handTracker.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });

        handTracker.onResults((res) => {
            const status = document.getElementById('gesture-status');
            const openValEl = document.getElementById('open-val');
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                isHandActive = true;
                const landmarks = res.multiHandLandmarks[0];
                const dist = Math.sqrt(Math.pow(landmarks[9].x - landmarks[0].x, 2) + Math.pow(landmarks[9].y - landmarks[0].y, 2));
                targetOpenFactor = THREE.MathUtils.clamp((dist - CONFIG.distFar) / (CONFIG.distNear - CONFIG.distFar), 0, 1);
                openValEl.innerText = Math.round(targetOpenFactor * 100) + "%";

                const isFingerUp = (tip, mcp) => landmarks[tip].y < landmarks[mcp].y;
                const fIndex = isFingerUp(8, 6);
                const fMiddle = isFingerUp(12, 10);
                const fRing = isFingerUp(16, 14);
                const fPinky = isFingerUp(20, 18);

                if (fIndex && !fMiddle && !fRing && !fPinky) currentNumber = 1;
                else if (fIndex && fMiddle && !fRing && !fPinky) currentNumber = 2;
                else if (fIndex && fMiddle && fRing && !fPinky) currentNumber = 3;
                else currentNumber = 0;

                const pinchDist = Math.sqrt(Math.pow(landmarks[4].x - landmarks[8].x, 2) + Math.pow(landmarks[4].y - landmarks[8].y, 2));
                const prevPinching = isPinching;
                isPinching = pinchDist < CONFIG.pinchThreshold;

                if (isPinching && !prevPinching && currentNumber === 0) {
                   focusedPhotoIndex = Math.floor(Math.random() * photoSprites.length);
                }
                if (!isPinching) focusedPhotoIndex = -1;
                status.innerText = isPinching ? "锁定：照片聚焦" : (currentNumber > 0 ? `消息推送: ${currentNumber}` : "视觉追踪中");
            } else {
                isHandActive = false; targetOpenFactor = 0; currentNumber = 0; isPinching = false; focusedPhotoIndex = -1;
                status.innerText = "系统待机";
            }
        });

        new Camera(videoElement, { onFrame: async () => await handTracker.send({ image: videoElement }), width: 480, height: 360 }).start().then(() => {
            document.getElementById('loading').style.opacity = '0';
            setTimeout(() => document.getElementById('loading').remove(), 1000);
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;

        if (!isHandActive) rotationVelocity.y += (CONFIG.autoRotateSpeed - rotationVelocity.y) * 0.05;
        else { rotationVelocity.x *= 0.9; rotationVelocity.y *= 0.9; }

        pointsGroup.rotation.x += rotationVelocity.x;
        pointsGroup.rotation.y += rotationVelocity.y;
        ring.rotation.z += CONFIG.ringRotateSpeed;

        if (currentNumber > 0) {
            pointsGroup.rotation.y = THREE.MathUtils.lerp(pointsGroup.rotation.y, 0, 0.05);
            pointsGroup.rotation.x = THREE.MathUtils.lerp(pointsGroup.rotation.x, 0, 0.05);
        }

        openFactor = THREE.MathUtils.lerp(openFactor, targetOpenFactor, 0.08);

        // 星体粒子逻辑
        const pAttr = planet.geometry.attributes.position;
        const pTAttr = planet.geometry.attributes.targetPos;
        const pTypeAttr = planet.geometry.attributes.type;
        const textPoints = (currentNumber > 0) ? originalData.textPoints[currentNumber] : null;

        for (let i = 0; i < pAttr.count; i++) {
            const i3 = i * 3;
            const noise = originalData.noiseOffsets;
            const floatScale = (1.0 + openFactor * 2.5);
            const offsetX = Math.sin(time * noise[i3] + noise[i3+2]) * CONFIG.floatIntensity * floatScale;
            const offsetY = Math.cos(time * noise[i3+1] + noise[i3+2]) * CONFIG.floatIntensity * floatScale;
            const offsetZ = Math.sin(time * (noise[i3]+noise[i3+1]) * 0.5) * CONFIG.floatIntensity * floatScale;

            const ox = originalData.planet[i3], oy = originalData.planet[i3+1], oz = originalData.planet[i3+2];
            const tx = pTAttr.getX(i), ty = pTAttr.getY(i), tz = pTAttr.getZ(i);

            let targetX = ox * (1 - openFactor) + tx * openFactor;
            let targetY = oy * (1 - openFactor) + ty * openFactor;
            let targetZ = oz * (1 - openFactor) + tz * openFactor;

            if (pTypeAttr.getX(i) === 1 && textPoints && textPoints.length > 0) {
                const textIdx = (i - CONFIG.planetSurfaceCount) % textPoints.length;
                const pt = textPoints[textIdx];
                targetX = pt.x + offsetX * 0.15; targetY = pt.y + offsetY * 0.15; targetZ = offsetZ * 0.1;
            } else {
                targetX += offsetX; targetY += offsetY; targetZ += offsetZ;
            }
            pAttr.setXYZ(i, targetX, targetY, targetZ);
        }
        pAttr.needsUpdate = true;

        // 照片逻辑
        photoSprites.forEach((sprite, idx) => {
            const data = sprite.userData;
            const isFocused = (idx === focusedPhotoIndex);
            const pFloatX = Math.sin(time * data.floatSpeed + data.floatSeed) * 1.2 * (0.5 + openFactor);
            const pFloatY = Math.cos(time * data.floatSpeed * 0.8 + data.floatSeed) * 1.2 * (0.5 + openFactor);
            let destPos = new THREE.Vector3().lerpVectors(data.originPos, data.targetPos, openFactor);
            destPos.x += pFloatX; destPos.y += pFloatY;
            let destScale = CONFIG.photoBaseSize * (0.8 + openFactor * 1.2);
            let destOpacity = 0;
            if (currentNumber === 0 && openFactor > CONFIG.photoDisplayThreshold) {
                const alpha = THREE.MathUtils.smoothstep(openFactor, CONFIG.photoDisplayThreshold, 0.8);
                destOpacity = alpha * 0.8;
            }
            if (focusedPhotoIndex !== -1 && currentNumber === 0) {
                if (isFocused) { destPos.set(0, 0, 8); destScale = 7; destOpacity = 1; }
                else { destOpacity = 0.05; destPos.z -= 10; }
            }
            sprite.position.lerp(destPos, 0.08);
            sprite.scale.setScalar(THREE.MathUtils.lerp(sprite.scale.x, destScale, 0.1));
            sprite.material.opacity = THREE.MathUtils.lerp(sprite.material.opacity, destOpacity, 0.1);
            sprite.renderOrder = isFocused ? 100 : 0;
        });

        // 星环波动逻辑
        const rAttr = ring.geometry.attributes.position;
        const rNoise = originalData.ringNoise;
        for (let i = 0; i < rAttr.count; i++) {
            const i3 = i * 3;
            const ox = originalData.ring[i3], oy = originalData.ring[i3+1], oz = originalData.ring[i3+2];
            const rFactor = 1 + Math.pow(openFactor, 2) * 8;
            const waveAmp = 0.4 + openFactor * 1.8;
            const waveY = Math.sin(time * 1.5 + i * 0.05 + rNoise[i]) * waveAmp;
            const wobble = Math.cos(time * 0.8 + rNoise[i]) * 0.2 * openFactor;
            rAttr.setXYZ(i, ox * rFactor + (ox * wobble), oy * (1 + openFactor * 3) + waveY, oz * rFactor + (oz * wobble));
        }
        rAttr.needsUpdate = true;

        camera.position.z = CONFIG.camDistance - openFactor * 10.0;
        planet.material.color.setHex(currentNumber > 0 ? 0xffffff : 0xffaa00);
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.onload = init;
</script>
</body>
</html>